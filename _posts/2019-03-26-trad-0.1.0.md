---
title: Trad 0.1.0 Beta 开发日志
repo: lc-soft/trad
---
## 2019-04-27

如果类继承自 Widget 类，则编译规则如下：

- 类方法的第一个参数都是 LCUI_Widget 类型的部件指针
- 类方法中的 this 表达式解析为部件私有数据的指针 _this
- 类方法中的第一行代码为 Widget_GetData() 函数调用，以获取私有数据的指针 _this
- constructor() 和 destructor() 方法会绑定到部件原型上
- 默认创建部件注册方法，命名格式为：`LCUIWidget_Add{部件类名}`

关于调整类方法参数列表的问题，有以下两种解决方案：

- 让 CClass 的 createMethod() 方法支持自定义方法的构造器：
    1. 添加一个继承自 CMethod 的 CLCUIWidgetMethod 类，覆写相关方法，在它输出参数列表时插入第一个参数
    1. 在 CClass 里添加 methodClass 成员变量，将 createMethod() 方法改为使用 this.methodClass 作为对象构造器来创建方法
- 由解析器来创建类方法：
    1. 调整 Class 的解析规则，不预先为类创建全部方法，改为在解析 MethodDefinition 结点时创建方法
    1. 移除 CClass 类的 createMethod() 方法，添加 addMethod() 方法
    1. 添加一个继承自 CMethod 的 CLCUIWidgetMethod 类，覆写相关方法，在它输出参数列表时插入 LCUI_Widget 类型的对象作为第一个参数
    1. LCUI 插件中添加 MethodDefinition 解析器，返回 CLCUIWidgetMethod 对象

第二种方案将类方法的构建交给了解析器，比较灵活。

Widget 构造方法和普通的类不一样，那么 CClass 的 createNewMethod() 和 createDeleteMethod() 方法应该改为由 Class 解析器来实现。

JavaScript 的 class 的 setter 和 getter 要成对存在，不能只继承基类中的 getter 或 setter。

## 2019-04-21

基于树的结构实现追加、查询、遍历操作就够了，现在整的 types、typesDict、scope、owner、module、parent 等成员变量只是在增加复杂度。

## 2019-04-11

props 和 state 解析器会互相调用导致栈溢出，两个解析器都有 parseMethodDefinition() 方法，props.js 里调用 super.parse() 时会调用 state.js 的 parse() 方法，而 state.js 调用 super.parse() 又会回到 props.js，一直循环。

``` text
RangeError: Maximum call stack size exceeded
    at LCUIParser.parse (c:\Users\LC\Documents\GitHub\trad\src\plugins\lcui\state.js:1:1)
    at LCUIParser.parseMethodDefinition (c:\Users\LC\Documents\GitHub\trad\src\plugins\lcui\props.js:85:26)
    at LCUIParser.parse (c:\Users\LC\Documents\GitHub\trad\src\plugins\lcui\state.js:106:28)
    at LCUIParser.parseMethodDefinition (c:\Users\LC\Documents\GitHub\trad\src\plugins\lcui\props.js:85:26)
    at LCUIParser.parse (c:\Users\LC\Documents\GitHub\trad\src\plugins\lcui\state.js:106:28)
    at LCUIParser.parseMethodDefinition (c:\Users\LC\Documents\GitHub\trad\src\plugins\lcui\props.js:85:26)
```

原因是 this 指向的是继承类，当前类没有指定方法时会往基类找，在 state.js 找到方法后，调用 super.parse() 实际是调用 props.js 的 parse()。解决方法是显式调用类原型里的方法，例如：

``` javascript
class StateBindingParser extends Compiler {
  // ...

  parse(input) {
    const method = 'parse' + input.type

    if (StateBindingParser.prototype.hasOwnProperty(method)) {
      return StateBindingParser.prototype[method].call(this, input)
    }
    return super.parse(input)
  }

  // ...
}
```

## 2019-04-06

class 结构体中的结构体成员应该用实体，而不是指针，这样只需为 class 结构体分配一次内存，省得再调用 malloc() 为结构体成员分配内存。

做些调整，CStruct 和 CClass 用于定义数据结构，CObject 用于定义对象，创建 CObject 对象时会记录所属的类型，然后根据该类型来构造属性列表。

解析 class 时应该先解析所有方法声明，然后再逐个解析方法内的代码块，不然在给部件添加事件绑定时会找不到事件处理函数。

LCUI 组件的数据绑定已经完成，接下来是事件绑定。

## 2019-04-05

解析 this 的成员表达式时，如果成员在这之前没有定义，则会为该成员定义一个结构体，但是现在的结构体是用 CStruct 对象表达的，既可以是类型也可以是对象，解析时也不好判断是应该定义结构体，还是应该定义结构体的对象，嵌套的结构体处理起来更麻烦。

## 2019-04-04

开始添加 LCUI_Object 数据结构。

## 2019-04-03

有些纠结要不要在这个版本中加入数据绑定功能，第一个版本搞这么复杂的功能会增加很多时间成本，以 LCFinder 为例，如果要加的话，需要解决以下问题：

- 如何高效渲染包含上万张缩略图的列表？
- 增加和删除若干个图片后，如何高效检测出列表中哪些部件需要改动？
- 数据类型不同，操作方法都不同，如何设计统一的接口和数据结构？

示例代码如下，text 对象被绑定到了两个部件上，hello() 方法中有 text 的赋值操作。

``` jsx
class MyWidget extends LCUI.Widget {
  constructor() {
    this.state = {
      text: String
    }
  }

  template() {
    return <Widget>
      <TextView>{this.state.text}</TextView>
      <TextEdit value={this.state.text} />
    </Widget>
  }

  hello() {
    this.state.text = 'hello'
  }
}
```

刚开始的想到的实现方法是将对象的写操作替换为 set() 函数调用，然后将绑定的部件操作放到 set() 函数里，为方便操作部件，会默认记录部件的指针，那么上面的代码翻译成 C 代码大致是这样的：

``` c
typedef struct MyWidgetRec_* MyWidget;
typedef struct MyWidgetRec_ MyWidgetRec;

struct MyWidgetRec_ {
        struct {
                LCUI_Widget _textview;
                LCUI_Widget _textedit;
        } refs;
        struct {
                char *text;
        } state;
};

// 省略其它代码 ...

// state 的操作函数都有 `$` 前缀且始终用 static 修饰，与其它函数隔离
static void MyWidget_$SetText(MyWidget _this, const char *text)
{
        _this.state.text = text;
        // 部件原型中有 settext 函数指针，每个部件都可以设置它，所以直接调用 Widget_SetText() 函数
        Widget_SetText(_this->refs._textview, text);
        // 绑定了 value 属性，说明 TextEdit 有处理方法，所以调用 TextEdit_SetValue()
        TextEdit_SetValue(_this->refs._textedit, text);
}

static void MyWidget_Hello(MyWidget _this)
{
        MyWidget_$SetText(_this, "hello");
}

// 省略其它代码 ...
```

从上述代码中可看出以下问题：

- 数据绑定功能太依赖编译器，以后要实现手动监听数据变化或类似于 Vue 的计算属性功能会很麻烦
- 存在内存泄漏问题，无法判断是否需要释放字符串

可以考虑添加一个 LCUI_Object 类型，用来记录数据类型、数据指针、析构函数、watcher 列表等，操作接口包括：创建、销毁、监听、解除监听、赋值等。

数据绑定的问题就不暂时不纠结了，先实现部件事件绑定功能。在 LCUI 中的部件事件处理函数有三个参数：绑定的部件、事件数据、触发器额外传入的数据，那么类的 _this 指针怎么传入？有两种做法：

- 放到 event->data 中。event->data 比较常用，在 LCFinder 中，每个图片部件都绑定了 click 事件，event->data 存的是与图片对应的文件信息，要是占用的话以后可能又需要改。
- 封装一次部件处理函数，将 _this 作为第三个参数传入。包装挺麻烦的，要创建一个结构体存储当前 this 指针和事件处理函数，再创建一个函数来转发事件给目标处理函数。

## 2019-03-31

在 React 中修改数据时需要调用 `this.setState()` 方法，然后在回调函数中修改状态并将新状态返回出去，这种机制要翻译成 C 代码的话复杂度有点高，还是改用 Vue 的做法吧，允许直接修改属性，等下一帧再批量更新与数据绑定的组件，实现起来简单些，只需要在翻译阶段推断出对象的类型，然后再将赋值语句翻译为对应的函数调用。

需要与组件绑定的数据都放到 state 里，props 中存放外部传入的数据，与其它的类成员隔离。

在翻译 import 语句时只是简单的替换成 `#include`，没对目标文件进行解析，导入的对象都是默认为 CObject 对象。以后可能需要加上解析功能，输出模块内导出的对象信息到文件里，类似于头文件，以节省以后的解析时间。

## 2019-03-29

在解析结点后直接输出结果的话不方便后续调整，例如：当 class 有继承基类但没有构造函数时，应该添加一个默认的构造函数；解析完后，需要将 export 修饰的对象和函数输出到头文件里。也就是说，应该在编译前加个解析步骤，将 acorn 解析好的语法树再解析为适合输出 C 代码的语法树，然后再经过编译输出为 C 代码。

解析 ReturnStatement 时需要知道 return 后面的内容是什么，如果是函数调用，那么在解析函数调用时还得判断上级解析器是不是 return 语句，是则不写入结果，而是以返回值形式将结果返回给 ReturnStatement 解析器，让它组装成完整的 return 语句。

## 2019-03-28

acornjs 的插件是在调用时继承 Parser 类的，要包装一层函数，多了一层缩进，看着难受。手动改 class 的 prototype 来改变父类虽然可行，但不能用 super 来调用基类的方法，会报语法错： `SyntaxError: 'super' keyword unexpected here`。

``` js
module.exports = function noisyReadToken(Parser) {
  return class extends Parser {
    readToken(code) {
      console.log("Reading a token!")
      super.readToken(code)
    }
  }
}
```

## 2019-03-27

与 LCUI 的相关的解析行为可以独立成插件，这样能方便其他人参考添加其它插件。

## 2019-03-26

准备搞个语言来简化 LCUI 的界面开发，包括数据绑定、事件绑定、模板、css 样式等，这些功能用 C 来写的话很麻烦，用新语言来搞会简单很多。

编程风格有 Vue 和 React 两种可以参考：

- **Vue**：Vue 组件的对象相相当于一个配置集，配置包括 props、data、watch、methods 等，与其说是在写编译器，更像是在写 C 语言版本的 vue-loader，想想就提不起兴趣，活在 Vue 的阴影下很没意思的，而且开发复杂度看上去也高。
- **React**: 组件继承自 React.Component，可使用 JSX 语法描述界面，this.state 和 this.props 分别访问组件内部数据和外部传入的数据。class、类方法、state 和 props 的定义以及变量的赋值是主要解析目标，复杂度尚可。

综上所述，决定用 React 的风格，语法解析用 acorn 来做，第一个版本先用 JavaScript 的语法，以后再按需求进行扩展。

acorn 输出的数据是树形结构，而现在的做法并没考虑到深层结点嵌套的情况，需要做些调整，支持解析单个结点并递归解析子结点。
