---
title: LCUI 2.0.0 Beta 开发日志
repo: lc-soft/LCUI
toc: true
categories:
  - 开发日志
  - LCUI
---
## 2020-01-31

调整一下尺寸计算规则：

- 如果尺寸为百分比单位，则在样式更新阶段和在父级容器的布局阶段计算出实际值。
- 如果尺寸为 px 单位的固定值，则根据现有的内容区域尺寸更新布局。
- 如果尺寸为 auto
  - 如果父级元素是 flexbox 布局，则根据现有的内容区域尺寸更新布局。
  - 如果是 inline-block 显示方式，则在布局后让尺寸自适应内容尺寸。
  - 如果是 block 显示方式，则在样式更新阶段计算实际值。

从上述规则可以用以下枚举来标识：

- **fixed:** 可以被直接计算出来的固定值，例如：100px、100%。
- **fill：** 填充可用空间，例如：非 flexbox 容器中，宽度为 auto 的 block 元素。
- **fit-content:** 自适应内容大小，例如：绝对定位的元素、非 flexbox 容器中的 inline-block 元素。
- **none：** 无需在样式更新阶段计算的值，它们会在父级容器布局完后计算实际值，例如：flexbox 容器中的元素。

Flex 布局已经完成，测试程序覆盖了 flex-grow、flex-shrink、justify-content、align-items、垂直居中布局、圣杯布局，接下来是添加单元测试，然后调整无效区域的收集机制。

[![Test flex layout](/static/images/devlog/test-flex-layout.gif "Test flex layout")](/static/images/devlog/test-flex-layout.gif)

## 2020-01-30

当 margin 为 auto 时，需要在布局时计算合适的值。在 flexbox 布局开始时，先重置这些 margin 值为 0，避免影响剩余空间的计算。

如果元素的尺寸是百分比单位，则在布局时只将其 min-content-size 算入容器内容尺寸，等容器内容尺寸计算完后再计算这些元素的实际尺寸。

flexbox 容器中的元素被拉伸/收缩后需要给它们更新一次布局，但现在的布局在更新后都会更新容器尺寸，那么该如何避免拉伸/收缩后的尺寸被布局流程重置？

`height: 100%` 的元素在布局完后，高度会被重置为 `min-content-height`，这尺寸计算流程有点混乱，样式更新和布局更新阶段都会更新尺寸。

## 2020-01-29

在 flexbox 容器的布局更新后，如果其中的 TextView 部件有样式更新则会触发重新布局导致尺寸被重置，如何处理？有两种办法：

1. TextView 部件是 block 或 inline-block 显示方式，在它更新布局后，判断父级是否为 flex 显示方式，是则不更新尺寸。
1. 当 flexbox 容器中的元素有触发重布局时，给 flexbox 容器也触发重布局。

第一个方法要加判断，比较麻烦，只能选择第二种，现阶段暂不考虑布局性能。

之前提到在更新样式时需要构造一颗树来记录需要更新布局的部件，实际上没必要这样做，因为更新部件样式是从顶到底递归的，可以在更新完子部件样式后再更新布局。

flex-basis 需要改成在布局时计算。

## 2020-01-26

简单的布局流程如下：

- 对元素进行分组，遍历时顺便统计 `margin: auto`、`flex-shrink`、`flex-grow` 的元素数量及总值
- 遍历组，计算该组在主轴上的剩余空间
  - 若剩余空间大于 0
    - 根据每个元素的 flex-grow 值来拉伸尺寸
    - 若还有剩余空间，则平均分配给 margin 值为 auto 的元素
    - 若还有剩余空间，则根据 justify-content 的值，给未设置 margin 的元素设置合适的 margin 值
  - 若剩余空间小于或等于 0
    - 根据每个元素的 flex-shrink 值来收缩尺寸

关于剩余空间的分配规则可参考[《控制Flex子元素在主轴上的比例》](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Controlling_Ratios_of_Flex_Items_Along_the_Main_Ax)，文档中提到 min-content-szie 和 max-content-size，它们在[《CSS Box Sizing Module Level 3》](https://drafts.csswg.org/css-sizing-3/#max-content)中有相关说明，看上去需要为 LCUI 添加能够计算它们的函数。

## 2020-01-24

是否需要将 flex 布局相关样式属性存到 widget 数据结构里？

- 是。好处是方便对比前后差异，判断是否需要重新计算布局，属性访问也方便。坏处是大部分部件都用不到 flex 布局，增加了部件的内存占用。
- 否。每次部件样式更新时，无论更新的样式属性是否与 flex 布局相关，都需要重新计算布局。

## 2020-01-23

block 布局系统及相关单元测试已经重写完毕，接下来是 flex 布局。

## 2020-01-19

在浏览器中，`vertical-align` 的计算值与基线有关，而基线又受到行高和是否有文字的影响，如果有文字则按照文字基线来计算内联块元素的位置，否则将内联块元素的最下边缘作为基线来计算元素位置，以下是测试效果：

[![Chrome vertical-align](/static/images/devlog/chrome-vertical-align.png "Chrome vertical-align")](/static/images/devlog/chrome-vertical-align.png)

如果给其中一个内联块元素添加文本，布局会变成这样：

[![Chrome vertical-align](/static/images/devlog/chrome-vertical-align-2.png "Chrome vertical-align")](/static/images/devlog/chrome-vertical-align-2.png)

在 LCUI 中，text-align 和 line-height 是 TextView 部件的私有样式属性，不参与布局系统的坐标计算，目前也不打算完全实现浏览器的这种基于基线的布局方式，所以，LCUI 对 vertical-align 的处理很简单，都基于当前行的实际高度来计算。

[![LCUI vertical-align](/static/images/devlog/lcui-vertical-align.png "LCUI vertical-align")](/static/images/devlog/lcui-vertical-align.png)

## 2020-01-12

启用 OpenMP 后 CPU 使用率一直在 80% 以上，即使没有重绘区域也是如此，看来需要根据重绘区域面积来自动决定是否使用 OpenMP。

block 和 inline-block 布局已经重写完成，接下来开始重写布局的单元测试。

## 2020-01-11

简单的布局流程如下：

- block
  1. 遍历子元素
  1. 计算子元素的位置
  1. 按行分组，计算每一行的最大高度
  1. 累加所有行的高度，作为容器的高度
- inline-block
  1. 遍历子元素
  1. 计算子元素的位置
  1. 按行分组，计算每一行的最大宽度和高度
  1. 将最大行宽和所有行的高度之和作为容器的宽高

inline-block 和 block 容器的布局类似，可以共用同一布局代码。

布局使用的是部件的 outer box，当 margin 为负数时，outer box 会比 border box 小。

一次遍历没法完成全部部件的坐标计算，那就遍历两次，第一次只按行分组子部件，计算内容区域的宽高，第二次再根据内容宽高来计算子元素的布局。

对于宽高是百分比单位的元素，可在更新样式时计算出准确的值，因为 root 的宽高必定是固定的，那么就能在更新样式后根据父级最大可用尺寸来计算出当前可用尺寸。假设有个 inline-block 显示方式的容器，如果它已指定宽度或最大宽度，则子元素宽度的百分比是相对于这个容器内容宽度，否则相对于最大可用宽度。

absolute 定位的元素脱离布局流，需要在计算完内容区尺寸后更新这些元素布局。

relative 和 absolute 定位的元素，它们的 left、right、top、bottom 属性的变更不需要重新布局，但考虑到现在并没有频繁改动这些属性的需求，所以就不花时间想优化方案了，直接触发重布局。

## 2020-01-05

在改动部件更新流程后无法通过布局测试，试着追加了几行 `LCUIWidget_Update()` 调用，可通过测试，看样子现有的布局效率很低，要往复更新好几次才能让布局完全正确。

准备重新调整部件更新方式，将布局任务与样式更新任务分离，在从根到子级更新部件样式时构造一棵树来记录需要更新布局的部件，更新完样式后再递归进这颗树从子级到根更新布局。

## 2019-12-29

改进后的重绘效果：

[![paint flashing](/static/images/devlog/improved-widget-style-diff.gif "Paint flashing")](/static/images/devlog/improved-widget-style-diff.gif)

## 2019-12-22

之前提了个重绘区域高亮的改进任务，看到有贡献者提交了 PR 就顺便测试了一下，以 helloworld 程序为例，鼠标悬停在输入框、 `hello, world!` 上会触发重绘，点击个按钮都会触发全屏重绘，这些重绘是多余的，为此，决定改进部件的更新流程。

首先，集中处理部件属性的差异对比和无效区域的标记，原有的部件属性更新函数只负责更新样式，不再考虑属性变化后的副作用。然后，将属性的更新分为两类：

- **布局相关**：包括宽高、定位、位置、内间距、外间距等属性在更新时会触发重新布局和重绘。
- **渲染相关**：包括背景、边框、阴影、可见性、透明度等属性在变化时只触发重绘，如果布局相关属性已更新，或父级部件不可见，或父级布局已标记内容区域需要刷新，则可跳过这些属性的差异对比。

这样处理后，就不需要 `RectList_Add()` 处理重复、重叠的脏矩形了。

## 2019-12-21

在启用 OpenMP 后，可将屏幕划分为 4 个区域来并行渲染，区域高度最小 200 像素。

当前机器的逻辑处理器是 8 个，将并行渲染线程数设置为 8 个后，渲染性能降低，改成 4 个较为合适。

## 2019-12-18

部件数量多的时候，存在以下问题：

- 脏矩形处理耗时长
- 部件样式更新耗时长

以下是性能探查器的检测结果：

[![Performance](/static/images/devlog/test-render-performance-01.png "Performance")](/static/images/devlog/test-render-performance-01.png)

测试程序在每次改完部件样式后会调用 `LCUIWidget_RefreshStyle()` 刷新全部部件样式，一般情况下应用程序并不需要主动调用这个函数，而是应该调用 `Widget_UpdateStyle()` 更新当前改动的部件样式。在调整测试程序后，渲染性能会从 30 帧会降到 5 帧，性能检测结果如下：

[![Performance](/static/images/devlog/test-render-performance-02.png "Performance")](/static/images/devlog/test-render-performance-02.png)

由于 `LCUIWidget_RefreshStyle()` 会标记全屏为无效区域，使后续添加的其它区域都会被忽略掉，所以花费在脏矩形处理上的时间很少。在改成 `Widget_UpdateStyle()` 调用后，总共会添加 3600 个脏矩形，而脏矩形的处理方式很粗暴，每次添加脏矩形时会遍历一遍脏矩形记录，导致性能非常低。
